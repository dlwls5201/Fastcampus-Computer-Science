# 가상 메모리의 이해

## 가상 메모리

- 메모리가 실제 메모리보다 많아 보이게 하는 기술
   - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
   - 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음


## 가상 메모리 기본 아이디어
- 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸때만 물리 주소록 바꿔주면 된다.
- virtual address (가상 주소): 프로세스가 참조하는 주소
   - 리눅스에서 프로세스는 4GB의 공간을 가짐
   - 1GB : 커널 영역, 3GB: 사용자 영역으로 사용
- physical address (물리 주소): 실제 메모리 주소
  - MMU(Memory Management Unit)
  - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

## 페이징 시스템(paging system)
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
- 하드웨어 지원이 필요
   - interX86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
- 리눅스에서는 4KB로 paging
- 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

## 쉬었다 가기
- 프로세스가 4GB를 사용하는 이유: 32bit 시스템에서 2의 32승이 4GB

## 페이징 시스템과 MMU(컴퓨터 구조)
- CPU는 가상 주소 접근시
   - MMU 하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성시, 페이지 테이블 정보 생성
   - PCB 등에서 해당 페이지 테이블에 접근 가능하고, 관련 정보는 물리 메모리에 적재
   - 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
   - CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서 물리 주소를 가져옴

## MMU와 TLB
- TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬

## 페이징 시스템과 공유 메모리
- 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)

## 요구 페이징 (Demand Paging)
- 프로세스 모든 데이터를 메모리로 적재하지 않고 실행 중 필요한 시점에서만 메모리로 적재함
 - 선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
 - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (페이지 교체 알고리즘 필요)

## 페이지 폴트 
- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림

## 페이지 폴트와 인터럽트 전체 설명

chapter36 : 05:30

## 생각해보기
- 페이지 폴트가 자주 일어나요면?
- 페이지 폴트가 안 일어나게 하려면?

## 페이지 교체 알고리즘

- FIFO
   - 가장 먼저 들어온 페이지를 내리자

- OPT
   - 최적 페이지 교체 알고리즘 (OPTime Replacement Algorithm)
   - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
   - 일반 OS에서는 구현 불가

 - LRU
    - LRU(Least Recently Used) Page Replacement Algorithm
    - 가장 오래 전에 사용된 페이지를 교체
    - OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도

- LFU
   -  LFU(Least Frequently Used) Page Replacement Algorithm
   - 가장 적게 사용된 페이지를 내리자

- 페이지 스왑 알고리즘 (NUR)
   - NUR(Not Used Recently) Page Replacement Algorithm
   - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
   - 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R,M)

## 참고: 메모리 지역성

## 스레싱
- 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황

## 세그멘테이션
- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그멘트로 분할 
   - 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할

## 참고
- 내부 단편화 (페이지 기법)
   - 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
- 외부 단편화 (세그멘테이션 기법)
   - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
- 세그멘테이션/페이징 모두 하드웨어 지원 필요
   - 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현


